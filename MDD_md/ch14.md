# 전역변수의 문제점

## 1. 개요

변수의 유효범위(Scope) 측면에서 변수는 크게 지역 변수와 전역 변수, 이 두 가지로 나뉘어진다.

**지역변수**란 함수 내에서 선언된 변수를 의미하며 지역 변수는 해당 함수 내에서만 접근이 가능합니다.

반대로 **전역변수는** 변수의 유효범위(Scope)가 전역(global, 즉 전체 영역)인 변수를 의미합니다. 유효범위가 전역인 만큼 해당 스크립트 파일 내에서 어디서든 접근이 가능합니다.  이러한 특징 덕분에 스크립트 내에서 공통으로 사용하는 데이터를 다룰 시에 전역변수가 유용하게 사용될 수 있습니다. 이처럼 전역 변수는 변수 사용의 편의성과 접근성을 증가시켜 줍니다.

하지만 이러한 장점을 지님에도 전역변수를 남발하는 것은 추천되지 않는데 이는 전역변수의 남발이 여러 문제점을 불러올 수 있기 때문입니다. 그러면 전역변수의 남발이 도대체 어떤 문제를 불러오는지에 대해 천천히 알아보도록 하겠습니다.

- 정리

<aside>
💡 지역변수:  함수 내에서 선언된 변수, 해당하는 함수 내에서만 유효 범위를 지닌다.

전역변수:  함수 밖에서 선언된 변수, 유효 범위가 전역(파일 전체 영역)이다.

</aside>

## 2. 변수의 생명 주기

변수는 마음만 먹으면 수 없이 만들 수 있는 것에 비해 컴퓨터의 메모리는 한정적입니다. 이 때문에 변수에 할당된 값이 계속해서 유지된다면 컴퓨터의 부하가 매우 커질 것입니다. 

그러므로 변수들에 저장된 값들은 메모리 공간의 효율성을 위해 필요 없다면 비워줄 필요가 있습니다. 이와 같이 변수가 선언되어 값이 할당된 뒤 메모리에서 사용되는 기간을 **변수의 생명 주기**라고 합니다. 

### 2-1) 지역 변수의 생명 주기

```jsx
function example() {
  var x = 10;
  console.log(x); // 10
  return x;
}

example();
console.log(x); // ReferenceError: Cannot access 'x' before initialization
```

위 예제와 같이 함수 내에서 선언된 변수인 지역 변수는 함수가 호출될 시에 생성되며 함수가 종료되면 소멸합니다. 즉, 지역 변수의 생명 주기는 함수의 호출 시부터 함수 종료 시 까지 입니다.  그러므로 지역 변수는 함수 작동 시에만 메모리 공간을 사용합니다.

### 2-2) 전역 변수의 생명 주기

```jsx
var x = "global";

function foo() {
  var x = "local";
  console.log(x);  
  return x;
}

foo();           // local
console.log(x);  // global
```

위 예제는 지역 변수와 전역 변수를 합쳐 놓은 예제입니다. 지역 변수에서 설명한 바와 같이  지역 변수는 함수가 종료됨과 동시에 생명 주기가 종료되기 때문에 함수 바깥에서 함수 내부에 있는 지역변수를 호출할 수 없습니다.  반면에 전역 변수는 전역 객체 window가 유효할 때까지, 즉 웹페이지를  닫을 시까지 유효합니다. 즉, var 키워드로 선언한 전역 변수의 생명 주기는 웹페이지를 닫을 시까지 라고 할 수 있습니다. 

<aside>
💡 * 요약

1.  **지역 변수의 생명 주기**는 함수의 호출 시부터 함수 종료 시 까지

2.  var 키워드로 선언한 **전역 변수의 생명 주기**는 웹페이지를 닫을 시까지

</aside>

## 3.  전역 변수의 문제점

### 3-1) 암묵적 결합

<aside>
💡 변수의 “암묵적 사용”이란?

● 변수가 암묵적으로 사용된다는 것은 변수가 명시적으로 선언되지 않았음에도 불구하고 코드 내에서 사용되는 것을 의미합니다.

</aside>

앞서 말했듯이 전역 변수는 스크립트 내 모든 영역에서 접근 가능합니다. 이로 인해 하나의 전역 변수가 여러 코드 영역에서 암묵적으로 사용될 수 있으며 이는 곧 특정 전역 변수를 여러 코드 영역에서 자유롭게 수정하고 접근할 수도 있다는 것을 의미합니다. 하지만 이렇게 여러 곳에서 변수에 접근하게 되면 변수가 코드에서 상호 의존하게 되면서 변수의 변경이 예기치 않은 결과를 초래할 수 있게 되어 코드의 유지보수와 디버깅이 매우 어려워질 수 있습니다.

### # 정리

- **암묵적 결합** ⇒ 전역 변수가 여러 코드 영역에서 암묵적으로 사용되어 각 영역의 변수가 서로 상호 의존하게 된 상태
- 암묵적 결합은 코드의 유지보수성과 가독성을 크게 떨어트리고 디버깅을 어렵게 함

### 3-2) 긴 생명 주기

컴퓨터의 메모리는 한정되어 있으며 메모리에 과부하가 일어나게 되면 컴퓨터의 성능이 매우 급감하게 됩니다. 이러한 현상을 방지하기 위해 JS 엔진은 필요 없는 변수, 즉 생명 주기가 끝난 변수들을 즉각적으로 메모리에서 지워버림으로서 메모리의 공간을 확보합니다. 

하지만 변수의 생명 주기 부분에서 봤듯이 전역 변수의 생명 주기는 브라우저나 프로그램을 닫아야만 종료되므로 사실상 생명 주기 종료 시점이 없다고 봐도 될 정도로 생명 주기가 매우 깁니다. 

이 때문에 전역 변수는 메모리에서 지워지지 않고 프로그램이 종료될 때까지 메모리의 공간을 차지하게 됩니다.  그래서 전역 변수를 사용하면 사용할수록 운용 가능한 메모리의 양이 점점 줄어들게 되고 이는 곧 메모리의 과부화를 야기하여 컴퓨터의 성능을 저하시키고 버그를 유발하는 등의 문제를 일으킵니다.

### # 정리

- JS 엔진은 생명 주기가 끝난 변수를 즉각적으로 메모리에서 제거함
- 전역 변수의 생명 주기는 매우 길어 메모리에서 잘 제거되지 않음 ⇒ 메모리 과부화로 인한 컴퓨터 성능 저하 야기

### 3-3) 스코프 체인 상에서 종점에 존재

<aside>
💡 스코프 체인(Scope Chain)이란?

● JS에서는 변수와 함수가 선언된 위치에 따라 그들의 유효 범위, 즉 스코프가 결정됩니다.
스코프 체인은 이와 같은 스코프들이 중첩되어 있는 경우에 변수와 함수를 찾기 위해 사용되는 매커니즘입니다.  스코프 매커니즘은 내부 스코프에서 외부 스코프로 순차적으로 진행됩니다.

</aside>

전역 변수는 스코프 체인 상에서 종점에 존재하기 때문에 전역 변수의 검색 속도는 다른 변수나 함수에 비해 가장 느립니다. 이는 결과적으로 프로그램의 실행 속도를 더디게 만들 수 있으며 전역 변수의 사용량이 많을수록 더욱 눈에 띄는 성능 저하가 일어날 수 있습니다.

### 3-4) 네임스페이스 오염

JS에서는 스크립트(sciript)를 통해 파일이 분리되어 있더라도 스코프를 다른 파일과 서로 공유할 수 있습니다. 하지만 동일한 이름의 전역 스코프를 script를 통해 서로 공유할 시 스코프가 서로 충돌하여 예상치 못한 동작을 일으킬 수 있습니다. 이와 같은 형상을 **네임스페이스 오염**이라고 합니다.

## 4. 전역 변수의 사용을 억제하는 방법

위에서 설명하였듯이 전역 변수의 남발은 여러 가지 문제점을 일으킬 수 있습니다. 그러므로 코드를 작성할 시에는 전역 변수의 사용을 최대한 피하고 지역 변수를 적극적으로 활용해야 합니다.

### 4-1 ) 즉시 실행 함수

```jsx
// 익명 함수 표현식을 괄호로 감싸고 바로 뒤에 ()를 붙여 함수를 즉시 호출
(function () {
  var message = 'Hello, IIFE!';
  console.log(message);
})();
```

즉시 실행 함수란 함수를 정의하자마자 즉시 호출하는 함수입니다.  모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 되게 된다. 즉,  즉시 실행 함수 내부의 변수들은 함수 내에서만 유효하고, 외부에서는 접근할 수 없게 되는 것입니다. 정리하자면 즉시 호출 함수는 함수 내부의 변수들의 스코프가 제한되므로 함수 내부에 있는 변수들이 전역 변수와 상호작용하는 것을 방지하여 변수 충돌이나 이름 중복 등으로 인한 예기치 않은 동작을 방지하여 코드의 안정성을 향상시킬 수 있습니다.

<aside>
💡 #  즉시 실행 함수 정리

● 즉시 실행 함수를 이용하면 함수 내부에 있는 변수들이 전역 변수와 상호작용하는 것을 방지함으로써 전역 변수의 사용을 제한할 수 있습니다.

</aside>

### 4-2) 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 형성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법입니다. 이를 통해 네임스페이스 오염을 방지하고 코드의 가독성 또한 향상시킬 수 있습니다.

```jsx
// 네임스페이스 객체 생성
var MyNamespace = {};

// 변수와 함수 추가
MyNamespace.myVariable = 10;

MyNamespace.myFunction = function() {
  console.log('Hello, World!');
};
```

### 4-3) 모듈 패턴

<aside>
💡 JS에서 모듈(Module)이란

● JS에서 모듈은 코드를 재사용하고 구성 요소를 독립적으로 유지하기 위한 개념으로 서로 관련 있는 변수,함수 등의 코드를 모아 하나의 파일이나 코드 블록으로 만든 것을 뜻합니다.
이러한 모듈은 코드의 재사용성을 높여주고 구성요소 간의 네임스페이스 충돌을 방지해 줍니다.

</aside>

- **모듈 패턴**은 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만드는 것입니다.  모듈 패턴은 JS의 기능인 클로저를 기반으로 동작하며 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 특징을 지닙니다.(클로저에 대해서는 24강 참고)
- **캡슐화**는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참고하고 조작할 수 있는 동작인 메소드를 하나로 묶는 것을 말하며 JS의 Class 형성이 대표적인 캡슐화 방법입니다.

```jsx
// class를 통한 캡슐화의 예시

class Computer {
  constructor( model, year) {
    this.model = model; // 모델명
    this.year = year;   // 생산 연도
  }

  startComputer() {
    console.log("컴퓨터 전원 On");
  }

  stopEngine() {
    console.log("컴퓨터 전원 Off");
  }
}
```

- 이러한 캡슐화는 객체의 특정 프로퍼티나 메소드를 외부로부터 감출 목적으로 사용되기도 하며 이를 **정보 은닉**이라고 합니다. 정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있습니다.
- **접근 제한**은 캡슐(클래스) 외부에 대해서 제한된 접근 권한을 제공하며 원치 않은 외부 접근으로부터 내부를 보호하는 기능을 담당합니다.  다만 JS에서는 다른 프로그래밍 언어와 달리 접근 제한자(public, private, protected…)를 제공하지 않습니다. 그러므로 클로저 활용이나 심볼을 이용하는 등 JS에서의 접근 제한 방법은 개발자들 간의 암묵적인 규칙과 관례에 의존합니다. 하지만 이러한 다양한 접근 제한 방법이 불편하다면 그냥 타입스크립트 활용하시면 됩니다.

### 4-4) ES6 모듈

- **ES6 모듈**은 말 그대로 ES6부터 추가된 JS 모듈 시스템이며 각각의 모듈마다 자체적인 모듈 스코프를 지니고 있기 때문에 해당 스코프 내에서 정의된 변수, 함수, 클래스 등은 기본적으로 해당 모듈 내에서만 접근 가능하므로 **전역 변수를 사용하지 않습니다**.

```html
<script type="module" src="app.mjs"></script>
<script type="module" src="lib.mjs"></script>

```

- 위 예제와 같이 scritpt 태크에 type=”module” 어트리뷰트를 추가하면 로드된 JS 파일은 모듈로서 동작합니다. 모듈의 파일 확장자는 mjs를 권장합니다.

- ES6 모듈의 가장 큰 특징은 **명시적인 내보내기와 가져오기(export and import)** 입니다. 이러한 명시적인 내보내기와 가져오기를 통해 모듈 간의 인터페이스를 명확하게 정의하고, 필요한 변수나 함수에만 접근할 수 있도록 제한할 수 있습니다.
- ES6 모듈 시스템을 활용한다면 코드의 가독성을 높임과 동시에 개발 효율성과 유지보수성을 높일 수 있습니다.
- 다만 ES6 모듈은 ES6부터 추가된 기능이기 때문에 **구형 브라우저에서는 작동하지 않으며** 사용할 수 있더라도 트랜스파일링이나 번들링을 필요로 하는 경우가 있습니다. 그러므로 구형 브라우저에서는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적입니다.